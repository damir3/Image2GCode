<!--
	Copyright (c) 2021 Damir Sagidullin

	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
	documentation files (the "Software"), to deal in the Software without restriction, including without limitation
	the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
	and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all copies or substantial portions
	of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
	TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
	CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

	(The above is MIT License: http://en.wikipedia.origin/wiki/MIT_License)
-->
<!DOCTYPE html>
<html>

<head>
	<!-- <meta charset="utf-8"> -->
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Image to GCode</title>
	<style>
		#viewport {
			position: absolute;
			left: 440px;
			top: 10px;
		}

		#previewCanvas {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		label {
			font-family: Arial, Helvetica, sans-serif;
			float: left;
			height: 20px;
			line-height: 20px;
			padding: 0;
			margin: 0;
		}

		input[type=file] {
			float: right;
		}

		input[type=number],
		input[type=text],
		input[type=checkbox] {
			font-family: "Lucida Console", "Courier New", monospace;
			width: 100px;
			height: 20px;
			float: right;
			margin: 0;
			padding: 0;
		}

		select {
			width: 104px;
			height: 20px;
			float: right;
			margin: 0;
			padding: 0;
		}

		.toolButton {
			float: right;
			width: 30px;
			height:30px;
			margin-left: 4px;
		}
	</style>
</head>

<body lang="en-US">
	<!-- <h1>Image to GCode</h1> -->
	<div style="border: 1px solid #888; width: 400px; padding: 10px; clear:both; line-height:30px;">
		<!-- <form> -->
		<label>Image:</label>
		<button style="float: right;" onclick="generateGradientImage()">Gradient</button>
		<input style="width: 270px;" id="imageFile" type="file" accept="image/*" onchange="loadImage()" />
		<br/>
		<label>Gamma: </label><input id="imageGamma" type="number" min="0.05" max="10" value="1" step="0.05" onchange="updatePreviewImage()""><br/>
		<label>Preview Scale: </label><input id="previewScale" type="number" min="0.25" max="10" value="1" step="0.25" onchange="updatePreview(event)""><br/>
		<br/>

		<div style="margin-bottom: 10px;">
		<label>Profile: </label>
		<button id="deleteProfile" title="Delete this profile" onclick="onDeleteProfile()" class="toolButton">&#10005;</button>
		<button id="saveProfile" title="Save current settings" onclick="onSaveProfile()" class="toolButton">&#128190;</button>
		<select id="profiles" style="width: 250px; height:30px;" onchange="onChangeProfile()"/>
		</select>
		</div><br/>

		<label>Halftone Mode: </label><input id="halftoneMode" type="checkbox" checked onchange="updatePreviewImage()"><br/>
		<label>Laser ON / OFF Command:</label>
		<select id="laserOnOffCmd"">
			<option value="0">M3 / M5</option>
			<option value="1">M106 / M107</option>
		</select><br/>
		<label>Burn Min Power [0 - 255]: </label><input id="minPower" type="number" min="0" max="255" value="10"><br/>
		<label>Burn Max Power [0 - 255]: </label><input id="maxPower" type="number" min="0" max="255" value="255"><br/>
		<label>Burn Speed (mm/min): </label><input id="burnSpeed" type="number" min="1" value="1000"><br/>
		<label>Travel Speed (mm/min): </label><input id="travelSpeed" type="number" min="1" value="8000"><br/>
		<label>Image Width (mm): </label><input id="width" type="number" value="100" min="1" max="10000" onchange="updatePreview(event)"><br/>
		<label>Image Height (mm): </label><input id="height" type="number" value="100" min="1" max="10000" onchange="updatePreview(event)"><br/>
		<label>Keep proportions: </label><input id="keepProportions" type="checkbox" checked onchange="updatePreview(event)"><br/>
		<label>Horizontal Resolution (mm/pixel): </label><input id="xRes" type="number" min="0.01" max="10" value="0.1" step="0.01" onchange="updatePreview(event)"><br/>
		<label>Vertical Resolution (mm/pixel): </label><input id="yRes" type="number" min="0.01" max="10" value="0.1" step="0.01" onchange="updatePreview(event)"><br/>
		<label>Overscan / Acceleration Distance (mm): </label><input id="overscanDist" type="number" min="0" max="100" value="3" step="0.1"><br/>
		<label>Border X (mm): </label><input id="borderX" type="number" value="5" min="0" onchange="updatePreview(event)"><br/>
		<label>Border Y (mm): </label><input id="borderY" type="number" value="5" min="0" onchange="updatePreview(event)"><br/>
		<label>Z Position (mm): </label><input id="zPos" type="number" value="0" min="0"><br/>
		<label>Zig-Zag Path: </label><input id="zigZagPath" type="checkbox" onchange="updateZigZag()"><br/>
		<div id="zigZagSettings" hidden>
			<label>Reverse Movement Offset (mm): </label><input id="reverseMovementOffset" type="number" min="0" max="1" value="0.25" step="0.01"><br/>
			<button onclick="calibrateReverseMovement()">Calibrate Reverse Movement Offset</button><br/>
		</div>
		<label>Cut Image: </label><input id="cutImage" type="checkbox" onchange="updateCut()"><br/>
		<div id="cuttingSettings" hidden>
			<label>Cutting Power [0 - 255]: </label><input id="cutPower" type="number" min="0" max="255" value="255"><br/>
			<label>Cutting Speed (mm/min): </label><input id="cutSpeed" type="number" min="1" value="200"><br/>
			<label>Cutting Passes: </label><input id="numCutPasses" type="number" min="1" value="1" step="1"><br/>
		</div>
		<br/>
		<button id="generateButton" onclick="generateGCode()" disabled style="width: 200px; height: 40px; position: relative; left: 50%; transform: translateX(-50%);">Generate G-Code</button><br/>
	</div>
	<div>
		<div id="viewport" hidden="true">
			<canvas id="previewCanvas"/>
		</div>
	</div>
</body>

<script type="text/javascript">
	var fileName;
	var viewport = document.getElementById("viewport");
	var sourceImage = new Image();
	var previewCanvas = document.getElementById("previewCanvas");
	var imageFile = document.getElementById("imageFile");
	var imageGamma = document.getElementById("imageGamma");
	var previewScale = document.getElementById("previewScale");
	var profilesSelect = document.getElementById("profiles");
	var generateButton = document.getElementById("generateButton");
	var profiles = {};
	var settings = {};
	["halftoneMode", "laserOnOffCmd", "minPower", "maxPower", "burnSpeed", "travelSpeed",
		"width", "height", "keepProportions", "xRes", "yRes", "overscanDist", "borderX", "borderY", "zPos",
		"zigZagPath", "reverseMovementOffset", "cutImage", "cutPower", "cutSpeed", "numCutPasses"].forEach(function(name) {
		settings[name] = document.getElementById(name);
	});

	function updateCut() {
		document.getElementById("cuttingSettings").hidden = !settings.cutImage.checked;
		viewport.style.border = settings.cutImage.checked ? "1px solid red" : "1px dashed #ccc";
	}

	function updateZigZag() {
		document.getElementById("zigZagSettings").hidden = !settings.zigZagPath.checked;
	}

	function onChangeProfile() {
		var profile = profiles[profilesSelect.value];
		if (profile !== undefined) {
			localStorage.setItem("activeProfile", profilesSelect.value);
			for (var propName in settings) {
				var value = profile[propName];
				if (value !== undefined) {
					var element = settings[propName];
					element[element.type === "checkbox" ? "checked" : "value"] = value;
				}
			}

			updateCut();
			updateZigZag();
		}
	}

	function loadProfiles() {
		var profilesData = localStorage.getItem("profiles");
		if (!profilesData) return;

		profiles = JSON.parse(profilesData);
		for (var profileName in profiles) {
			var option = document.createElement("option");
			option.value = option.text = profileName;
			profilesSelect.add(option);
		}
		profilesSelect.value = localStorage.getItem("activeProfile");
		onChangeProfile();
	}

	loadProfiles();
	updateCut();
	updateZigZag();

	function saveProfiles() {
		localStorage.setItem("profiles", JSON.stringify(profiles));
		localStorage.setItem("activeProfile", profilesSelect.value);
	}

	function onSaveProfile() {
		var profileName = prompt("Save Profile as", profilesSelect.value || "Default");
		if (profileName) {
			var option = Array.from(profilesSelect.options).find(function(option) { return option.value === profileName; });
			if (!option) {
				option = document.createElement("option");
				option.value = option.text = profileName;
				profilesSelect.add(option);
			}
			profilesSelect.value = profileName;
			var json = {};
			for (var propName in settings) {
				var element = settings[propName];
				json[element.id] = element.type === "checkbox" ? element.checked : element.value;
			}
			profiles[profileName] = json;
			saveProfiles();
		}
		console.log(profileName);
	}

	function onDeleteProfile() {
		var option = Array.from(profilesSelect.options).find(function(option) { return option.value === profilesSelect.value; });
		if (option && confirm("Delete " + option.text + " Profile?")) {
			delete profiles[option.value];
			profilesSelect.remove(option);
			profilesSelect.value = null;
			saveProfiles();
		}
	}

	function sRGB2Linear(c) {
		c /= 255.0;
		return c < 0.04045 ? (c / 12.92) : Math.pow((c + 0.055) / 1.055, 2.4);
	}

	function linear2sRGB(l) {
		return Math.round((l > 0.0031308 ? 1.055 * (Math.pow(l, (1.0 / 2.4))) - 0.055 : 12.92 * l) * 255);
	}

	function roundCoord(x) {
		return Math.round(x * 100) / 100;
	}

	function createEngravingImage(disableHalftone) {
		var width = Math.round(settings.width.value / settings.xRes.value);
		var height = Math.round(settings.height.value / settings.yRes.value);

		var image = sourceImage;
		var canvas, ctx;

		do {// scale image
			canvas = document.createElement("canvas");
			canvas.width = Math.max(image.width >> 1, width);
			canvas.height = Math.max(image.height >> 1, height);
			ctx = canvas.getContext("2d");
			ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
			console.log(image.width, image.height, "->", canvas.width, canvas.height);
			image = canvas;
		} while (image.width > width || image.height > height);

		// prepare greyscale data
		var gamma = parseFloat(imageGamma.value);
		var srcData = ctx.getImageData(0, 0, width, height).data;
		var destData = new Int16Array(width * height);
		for (var y = 0, i = 0; y < height; y++) {
			for (var x = 0; x < width; x++, i++) {
				var si = i << 2;
				var l = 0.2126 * sRGB2Linear(srcData[si]) + 0.7152 * sRGB2Linear(srcData[si + 1]) + 0.0722 * sRGB2Linear(srcData[si + 2]);
				destData[i] = linear2sRGB(Math.pow(l, gamma));
			}
		}

		if (settings.halftoneMode.checked && !disableHalftone) {
			// Jarvis-Judice-Ninke Dithering
			var matrix = [[0, 0, 0, 7, 5], [3, 5, 7, 5, 3], [1, 3, 5, 3, 1]];
			for (var y = 0, i = 0; y < height; y++) {
				for (var x = 0; x < width; x++, i++) {
					var c = destData[i];
					destData[i] = c < 128 ? 0 : 255;
					// destData[i] = c < 32 ? 0 : (c < 96 ? 63 : (c  < 160 ? 127 : (c < 224 ? 191 : 255)));
					var quantError = c - destData[i];
					if (quantError === 0) continue;
					for (var iy = 0; iy < 3; iy++) {
						var my = y + iy;
						if (my >= height) continue;
						for (var ix = 0; ix < 5; ix++) {
							var m = matrix[iy][ix];
							if (m === 0) continue;
							var mx = x + ix - 2;
							if (mx < 0 || mx >= width) continue;
							destData[mx + my * width] += quantError * m / 48;
						}
					}
				}
			}
		}

		return {
			width: width,
			height: height,
			data: destData,
		};
	}

	function updatePreviewImage() {
		if (!sourceImage.width || !sourceImage.height) return;

		var image = createEngravingImage();
		var width = previewCanvas.width = image.width;
		var height = previewCanvas.height = image.height;

		// copy image data to canvas
		var ctx = previewCanvas.getContext("2d");
		var imgData = ctx.createImageData(width, height);
		var src = image.data;
		var dest = imgData.data;
		for (var y = 0, i = 0; y < height; y++) {
			for (var x = 0; x < width; x++, i++) {
				var di = i << 2;
				dest[di] = dest[di + 1] = dest[di + 2] = src[i];
				dest[di + 3] = 255;
			}
		}
		ctx.putImageData(imgData, 0, 0);
	}

	function updatePreview(event) {
		var keepProportions = settings.keepProportions.checked;
		if (keepProportions && sourceImage.width && sourceImage.height) {
			if (event.target === settings.width || event.target === settings.keepProportions) {
				settings.height.value = settings.width.value * sourceImage.height / sourceImage.width;
			} else if (event.target === settings.height) {
				settings.width.value = settings.height.value * sourceImage.width / sourceImage.height;
			}
		}

		var mm2px = previewScale.value * 128 / 25.4;
		var previewWidth = Math.round(settings.width.value * mm2px);
		var previewHeight = Math.round(settings.height.value * mm2px);
		var borderX = settings.borderX.value * mm2px;
		var borderY = settings.borderY.value * mm2px;
		previewCanvas.style.width = previewWidth + "px";
		previewCanvas.style.height = previewHeight + "px";
		viewport.style.width = (previewWidth + borderX * 2) + "px";
		viewport.style.height = (previewHeight + borderY * 2) + "px";

		switch (event.target) {
			case imageGamma:
			case settings.width:
			case settings.height:
			case settings.keepProportions:
			case settings.xRes:
			case settings.yRes:
				updatePreviewImage();
				break;
		}
	}

	function generateGradientImage() {
		var width = 256;
		var height = 16;
		sourceImage = document.createElement("canvas");
		sourceImage.width = width;
		sourceImage.height = height;
		var ctx = sourceImage.getContext("2d");
		var imgData = ctx.createImageData(width, height);
		var dest = imgData.data;

		for (var y = 0, i = 0, h2 = height >> 1; y < height; y++) {
			for (var x = 0; x < width; x++) {
				dest[i++] = x;
				dest[i++] = x;
				dest[i++] = x;
				dest[i++] = 255;
			}
		}

		ctx.putImageData(imgData, 0, 0);

		imageFile.value = ""
		imageGamma.value = 1;
		// imageGamma.disabled = true;
		updatePreview({ target: settings.width });

		viewport.hidden = false;
		generateButton.disabled = false;
		fileName = "gradient";
	}

	function calibrateReverseMovement() {
		var width = 50;
		var height = 100;
		settings.width.value = 5;
		settings.height.value = 10;
		sourceImage = document.createElement("canvas");
		sourceImage.width = width;
		sourceImage.height = height;
		var ctx = sourceImage.getContext("2d");
		var imgData = ctx.createImageData(width, height);
		var dest = imgData.data;

		for (var y = 0, i = 0, h2 = height >> 1; y < height; y++) {
			for (var x = 0; x < width; x++, i+=4) {
				dest[i] = dest[i+1] = dest[i+2] = ((x >> 1) & 1) ? 255 : 0;
				dest[i+3] = 255;
			}
		}

		ctx.putImageData(imgData, 0, 0);

		imageFile.value = ""
		imageGamma.value = 1;
		// imageGamma.disabled = true;
		updatePreview({ target: settings.width });

		viewport.hidden = false;
		generateButton.disabled = false;
		fileName = "zigzag-calibration";

		generateGCode(true);
	}

	function loadImage() {
		fileName = imageFile.value.split(/(\\|\/)/g).pop().replace(/\.[^/.]+$/, "");
		sourceImage = new Image();
		sourceImage.onload = function(event) {
			imageGamma.value = 1;
			// imageGamma.disabled = false;
			updatePreview({ target: settings.width });

			viewport.hidden = false;
			generateButton.disabled = false;
		};

		viewport.hidden = true;
		generateButton.disabled = true;
		sourceImage.src = imageFile.files.length > 0 ? window.URL.createObjectURL(imageFile.files[0]) : "";
	}

	function generateGCode(zigZagCalibration) {
		if (!sourceImage.width || !sourceImage.height) return;

		var image = createEngravingImage(zigZagCalibration);
		var width = image.width;
		var height = image.height;
		var data = image.data;

		var onCmd = "M3 I S";
		var offCmd = "M5";
		if (parseInt(settings.laserOnOffCmd.value) > 0) {
			onCmd = "M106 S";
			offCmd = "M107";
		}

		var dx = parseFloat(settings.xRes.value);
		var dy = parseFloat(settings.yRes.value);
		var ad = Math.floor(settings.overscanDist.value / dx);
		var borderX = parseFloat(settings.borderX.value);
		var borderY = parseFloat(settings.borderY.value);
		var minPower = parseFloat(settings.minPower.value);
		var maxPower = parseFloat(settings.maxPower.value);
		var cutPower = parseFloat(settings.cutPower.value);
		var travelSpeedCmd = " F" + settings.travelSpeed.value;
		var laserSpeedCmd = " F" + settings.burnSpeed.value;
		var cuttingSpeedCmd = " F" + settings.cutSpeed.value;

		var zigZag = settings.zigZagPath.checked || zigZagCalibration;
		var reverseOffset = zigZag ? (zigZagCalibration ? height * dy * 0.1 : parseFloat(settings.reverseMovementOffset.value)) : 0;

		var offsetX = Math.max(borderX, parseFloat(settings.overscanDist.value) + reverseOffset);

		var gcode = [];
		gcode.push("; Created using Image2GCode v1.0.0 https://github.com/damir3/Image2GCode");
		gcode.push("; Image Size: " + (width * dx) + "x" + (height * dy) + " mm");
		gcode.push("; Gamma: " + imageGamma.value);
		gcode.push("; Mode: " + (settings.halftoneMode.checked ? "halftone" : "greyscale"));
		gcode.push("; Resolution: " + width + "x" + height + " px, " + dx + "x" + dy + " mm/px");
		gcode.push("; Laser Speed: " + settings.burnSpeed.value + " mm/sec");
		gcode.push("; Travel Speed: " + settings.travelSpeed.value + " mm/sec");
		gcode.push("; Power: [" + minPower + ", " + maxPower + "]");
		gcode.push("; Path: " + (zigZag ? "Zig-Zag" : "Raster"));
		gcode.push(";");

		gcode.push("; Image engraving");
		gcode.push(offCmd);
		gcode.push("G1 X" + roundCoord(offsetX - ad * dx) + " Y" + roundCoord(borderY) + " Z" + roundCoord(zPos.value) + travelSpeedCmd);

		for (var y = 0; y < height; y++) {
			if (zigZagCalibration) {
				reverseOffset = y * dy * 0.1;
			}

			gcode.push("");
			if (y > 0) {
				gcode.push(offCmd);
				gcode.push("G1 X" + roundCoord(((zigZag && (y & 1)) ? width + ad - reverseOffset : -ad) * dx + offsetX) + " Y" + roundCoord(y * dy + borderY) + travelSpeedCmd);
			}
			gcode.push("G1" + laserSpeedCmd);

			for (var ix = -ad, lastPower = -1; ix < width + ad; ix++) {
				var reverse = zigZag && (y & 1);
				var x = reverse ? (width - 1 - ix) : ix;
				var power = 0;
				if (x >= 0 && x < width) {
					var c = data[x + (height - 1 - y) * width];
					power = Math.round(minPower + (1.0 - c / 255.0) * (maxPower - minPower));
				}
				if (lastPower !== power) {
					lastPower = power;
					gcode.push(onCmd + power);
				}
				gcode.push("G1 X" + roundCoord(x * dx + offsetX + (reverse ? -reverseOffset : dx)));
			}
		}

		if (settings.cutImage.checked) {
			var x1 = roundCoord(offsetX - borderX);
			var x2 = roundCoord(x1 + width * dx + borderX * 2);
			var y1 = 0;
			var y2 = roundCoord(y1 + height * dy + borderY * 2);
			gcode.push("");
			gcode.push("; Image cutting");
			gcode.push(offCmd);
			gcode.push("G1 X" + x1 + " Y" + y2 + travelSpeedCmd);
			gcode.push(onCmd + cutPower);
			gcode.push("G1" + cuttingSpeedCmd);
			for (var i = parseInt(settings.numCutPasses.value); i > 0; i--) {
				gcode.push("G1 X" + x2 + " Y" + y2);
				gcode.push("G1 X" + x2 + " Y" + y1);
				gcode.push("G1 X" + x1 + " Y" + y1);
				gcode.push("G1 X" + x1 + " Y" + y2);
			}
		}

		gcode.push(offCmd);
		gcode.push("G1 X0 Y0" + travelSpeedCmd);
		gcode.push("");

		var blob = new Blob([gcode.join("\n")], { type: "text/plain" });
		var a = document.createElement("a");
		a.download = fileName + ".gcode";
		a.href = window.URL.createObjectURL(blob);
		a.click();
	}
</script>

</html>